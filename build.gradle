import org.codehaus.plexus.util.cli.Commandline
import javax.swing.table.DefaultTableCellRenderer

import com.google.gson.Gson
import com.google.gson.GsonBuilder
import com.google.gson.JsonArray
import com.google.gson.JsonObject

buildscript {
    repositories {
        // These repositories are only for Gradle plugins, put any other repositories in the repository block further below
        maven { url = 'https://maven.minecraftforge.net' }
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
        classpath group: 'com.google.code.gson', name: 'gson', version: '2.8.8', changing: true
    }
}
apply plugin: 'net.minecraftforge.gradle'
// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
apply plugin: 'eclipse'
apply plugin: 'maven-publish'

version = project.mod_version
group = "${group_name}.${mod_id}" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = project.mod_id

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(project.minimum_java_version)

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))
minecraft {
    // The mappings can be changed at any time and must be in the following format.
    // Channel:   Version:
    // snapshot   YYYYMMDD   Snapshot are built nightly.
    // stable     #          Stables are built at the discretion of the MCP team.
    // official   MCVersion  Official field/method names from Mojang mapping files
    //
    // You must be aware of the Mojang license when using the 'official' mappings.
    // See more information here: https://github.com/MinecraftForge/MCPConfig/blob/master/Mojang.md
    //
    // Use non-default mappings at your own risk. They may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    mappings channel: 'official', version: project.minecraft_version

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') // Currently, this location cannot be changed from the default.

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            mods {
                mod_id {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            mods {
                mod_id {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            args '--mod', "${mod_id}", '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                mod_id {
                    source sourceSets.main
                }
            }
        }
    }
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    // Put repositories for dependencies here
    // ForgeGradle automatically adds the Forge maven and Maven Central for you

    // If you have mod jar dependencies in ./libs, you can declare them as a repository like so:
    // flatDir {
    //     dir 'libs'
    // }
}

dependencies {
    // Specify the version of Minecraft to use. If this is any group other than 'net.minecraft', it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency, and its patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    // Real mod deobf dependency examples - these get remapped to your current mappings
    // compileOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}:api") // Adds JEI API as a compile dependency
    // runtimeOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}") // Adds the full JEI mod as a runtime dependency
    // implementation fg.deobf("com.tterrag.registrate:Registrate:MC${mc_version}-${registrate_version}") // Adds registrate as a dependency

    // Examples using mod jars from ./libs
    // implementation fg.deobf("blank:coolmod-${mc_version}:${coolmod_version}")

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}

// Example for how to get properties into the manifest for reading at runtime.
jar {
    manifest {
        attributes([
                "Specification-Title"     : "${mod_id}",
                "Specification-Vendor"    : "${mod_author}",
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : "${mod_name}",
                "Implementation-Version"  : "${mod_version}",
                "Implementation-Vendor"   : "${mod_author}",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

// Example configuration to allow publishing using the maven-publish plugin
// This is the preferred method to reobfuscate your jar file
jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
// publish.dependsOn('reobfJar')

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact jar
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/mcmodsrepo"
        }
    }
}

/**
 *          JsonBuilder class
 *
 * A utility class that makes building json
 * files for data generation easier and shorter.
 *
 * In short it's a wrapper class for
 * JsonObject and Json Array
 *
 * @author Hunter "Pie" Spragg
 */
class JsonBuilder {
    // Gson is google's json library and we will use it for pretty printing the output.
    private static Gson gson = new GsonBuilder().setPrettyPrinting().create()
    // Whether or not the JsonBuilder is wrapping a JsonArray or JsonObject
    private boolean isArray
    // The wrapped values.
    private JsonObject base
    private JsonArray array

    JsonBuilder() {
        this.base = new JsonObject();
        this.isArray = false
    }
    JsonBuilder(JsonObject base) {
        this.base = base
        this.isArray = false
    }
    JsonBuilder(JsonArray array) {
        this.array = array
        this.isArray = true
    }


    def add(String propertyName) {
        if(!isArray) {
            JsonObject object = new JsonObject()
            base.add(propertyName, object)
            return new JsonBuilder(object)
        }else {
            JsonObject object = new JsonObject()
            array.add(object)
            return new JsonBuilder(object)
        }
    }

    def addArray() {
        if(!isArray) {
            throw new UnsupportedOperationException("Properties of Objects must be named!")
        }
        JsonArray array = new JsonArray()
        array.add(array)
        return new JsonBuilder(array)
    }

    def addObject() {
        if(!isArray) {
            throw new UnsupportedOperationException("Properties of Objects must be named!")
        }
        JsonObject object = new JsonObject()
        array.add(object)
        return new JsonBuilder(object)
    }

    def addArray(String propertyName) {
        if(!isArray) {
            JsonArray array = new JsonArray()
            base.add(propertyName, array)
            return new JsonBuilder(array)
        } else {
            JsonArray array = new JsonArray()
            base.add(array)
            return new JsonBuilder(array)
        }
    }

    def addProperty(String propertyName, String value, Object... formatting) {
        if(!isArray) {
            base.addProperty(propertyName, String.format(value, formatting))
            return this
        }else {
            throw new UnsupportedOperationException("You cannot add a property to an array!")
        }
    }

    def addProperty(String propertyName, String value) {
        if(!isArray) {
            base.addProperty(propertyName, value)
            return this
        }else {
            throw new UnsupportedOperationException("You cannot add a property to an array!")
        }
    }

    def addProperty(String propertyName, Number value) {
        if(!isArray) {
            base.addProperty(propertyName, value)
            return this
        } else {
            throw new UnsupportedOperationException("You cannot add a property to an array!")
        }
    }

    def addProperty(String propertyName, Boolean value) {
        if(!isArray) {
            base.addProperty(propertyName, value)
            return this
        } else {
            throw new UnsupportedOperationException("You cannot add a property to an array!")
        }
    }

    def addProperty(String propertyName, Character value) {
        if(!isArray) {
            base.addProperty(propertyName, value)
            return this
        } else {
            throw new UnsupportedOperationException("You cannot add a property to an array!")
        }
    }

    /**
     * Takes a file directory and file name
     * and generates a .json file at the location
     * "dir/fileName.json"
     *
     * @param dir       The directory the file will be located in
     * @param fileName  The name of the file being generated
     */
    def toJsonFile(String dir, String fileName) {
        // create the folders if it does not exist.(otherwise it will throw exception)
        println("Now generating json for "+fileName)

        File directory = new File( "${dir}")
        if ( !directory.exists() ){
            println("Creating new file directory...")
            directory.mkdir()
            println("Directory Created")
        }else {
            println("Directory Found")
        }

        println("Creating new json file...")
        // create the file and write text to it.
        File jsonFile = new File("${dir}/${fileName}.json")
        println("Writing to json file...")
        jsonFile.text = gson.toJson(base)
        println("Json File Created at "+"${dir}/${fileName}.json")
    }


}

/**
 * This method is used to validate, trim, and clean up each line of the generate script.
 *
 * @param line The line of the generation script
 *
 * @returns String[] array of lowercase args.
 */
def splitLine(String line) {
    // Trim the line in case a student adds spaces to the sides.
    // Replace the line with all lowercase in case a student accidentally put
    // capital letters.
    line = line.toLowerCase().trim()

    // Check to see if the student forgot to put a
    // space between the generation type and the name
    // The length check is to make sure this is not just white space or next line characters
    if(!line.contains(" ") && line.length() > 3) {
        println("The following line is missing a space!")
        println(line)
        // Let's throw an error here so the student knows that something didn't work properly.
        throw new Exception("The following line does not contain a space: \""+line+"\"!")
    }

    // Check to see if the student accidentally placed two spaces on the same line
    // This could be a difficult error to spot normally esspecially if they are side-by-side.
    if(line.lastIndexOf(' ') != line.indexOf(' ')){
        println("The following line has too many spaces!!!")
        println(line)
        // Let's throw an error here so the student knows that something didn't work properly.
        throw new Exception("The following line contains too many spaces!: \""+line+"\"!")
    }

    return line.split(' ')
}

class ItemJSONTask extends DefaultTask {
    private String MODID = "${project.mod_id}"

    def writeToFile(String name, String type){
        JsonBuilder builder = new JsonBuilder();

        // If item type is an egg, use egg template as parent
        // Otherwise assume parent is the type of item.
        if(type == ("egg")){
            name = name + "_egg"

            builder.addProperty("parent", "minecraft:item/template_spawn_egg")
        }else{
            builder.addProperty("parent", "item/"+type.toLowerCase())
            builder.add("textures").addProperty("layer0", "%s:item/%s", MODID, name)
        }

        builder.toJsonFile(
                "${project.projectDir}/src/main/resources/assets/"+MODID+"/models/item",
                name
        )

    }

    @TaskAction
    def greet() {
        String[] listy
        new File("${project.projectDir}/src/main/resources/generate/items").eachLine { line ->
            listy = project.splitLine(line)
            writeToFile(listy[1], listy[0])
        }
    }
}

task generateItemJSONs(type: ItemJSONTask){
    group = 'forgegradle runs'
    description = 'A gradle task to generate all item jsons from the items file. Use generated for regular items, handheld for tools, and egg for entity egg jsons.'
}


class BlockJSONTask extends DefaultTask {
    private String MODID = "${project.mod_id}"

    def blockstatesJSON(name) {
        JsonBuilder builder = new JsonBuilder();
        builder.add("variants")
                .add("")
                .addProperty("model", "%s:block/%s", MODID, name)

        builder.toJsonFile(
                "${project.projectDir}/src/main/resources/assets/"+MODID+"/blockstates",
                name
        )
    }

    def blockJSONMulti(name){
        JsonBuilder build = new JsonBuilder();

        build.addProperty("parent","minecraft:block/bedrock")

        // What this does is that it generates a json that has different textures for each side, but only uses two
        // textures. Obviously this can be extended to have more than just 2 textures, and in theory you could make
        // each side of the block unique. For this case, the textures on the top and bottom must be called "[block_name]_top"
        // and the texture on the sides "[block_name]_sides"

        String[] directions = new String[]{"up","down","north","east","south","west"}
        JsonBuilder textures = build.add("textures");
        for (String direction : directions) {
            textures.addProperty(direction, "%s:block/%s_%s", MODID, name, direction)
        }

        build.toJsonFile(
                "${project.projectDir}/src/main/resources/assets/"+MODID+"/models/block",
                name
        )
    }
    def blockJSON(name){
        JsonBuilder build = new JsonBuilder()

        build.addProperty("parent","minecraft:block/cube_all")
        build.add("textures").addProperty("all","%s:block/%s", MODID, name)

        // TODO: Need to figure out how to apply textures properly for various types

        build.toJsonFile(
                "${project.projectDir}/src/main/resources/assets/"+MODID+"/models/block",
                name
        )
    }
    def itemJSON(name){
        JsonBuilder builder = new JsonBuilder()
        builder.addProperty("parent", "%s:block/%s",MODID, name)

        builder.toJsonFile(
                "${project.projectDir}/src/main/resources/assets/"+MODID+"/models/item",
                name
        )
    }


    @TaskAction
    def greet() {
        String[] listy
        new File("${project.projectDir}/src/main/resources/generate/blocks").eachLine { line ->
            listy = project.splitLine(line)
            // If the block has multiple sides.
            if(listy[0].equals("multi")){
                blockJSONMulti(listy[1])
            }
            // If the block is the same on all sides.
            if(listy[0].equals("same")){
                blockJSON(listy[1])
            }

            // Generate blockstates for the block
            blockstatesJSON(listy[1])
            // Generate item jsons for the block item.
            itemJSON(listy[1])
        }
    }
}

task generateBlockJSONs(type: BlockJSONTask){
    group = 'forgegradle runs'
    description = 'A gradle task to generate all block jsons in the blocks file. Choose same for all sides to be the same and multi to decide each side of the block (use _up, _down, _south, _north, _east, _west for texture names).'
}

class LoottableGenTask extends DefaultTask {
    private String MODID = "${project.mod_id}"

    def writeToFile(String name, String type) {
        JsonBuilder build = new JsonBuilder()
        if(type != "ore") {
            build.addProperty("type", "minecraft:%s", type)
        } else{
            build.addProperty("type", "minecraft:block")
        }
        JsonBuilder pool = build.addArray("pools").addObject()
        pool.addProperty("rolls", 1.0)
        pool.addProperty("bonus_rolls", 0.0)
        JsonBuilder entry = pool.addArray("entries").addObject()
        entry.addProperty("type","minecraft:item")

        if(type == "block" || type == "ore") {
            entry.addProperty("name", "%s:%s", MODID, name)
            pool.addArray("conditions")
                    .addObject()
                    .addProperty("condition", "minecraft:survives_explosion")
            if(type == "ore") {
                name += "block"
            }
            build.toJsonFile(
                    "${project.projectDir}/src/main/resources/data/" + MODID + "/loot_tables/blocks",
                    name
            )
        }else if(type == "entity") {
            entry.addProperty("name", "minecraft:rotten_flesh")
            build.toJsonFile(
                    "${project.projectDir}/src/main/resources/data/" + MODID + "/loot_tables/entities",
                    name
            )
        }
    }
    @TaskAction
    def greet() {
        String[] listy
        new File("${project.projectDir}/src/main/resources/generate/loot").eachLine { line ->
            listy = project.splitLine(line)
            writeToFile(listy[1], listy[0])
        }
    }

}
task generateLootTables(type: LoottableGenTask) {
    group = 'forgegradle runs'
    description = 'A gradle task to generate loot tables for blocks to drop themselves.'
}

class ChangeModID extends DefaultTask {
    private String OLD_NAME = "${project.old_mod_id}"
    private String NEW_NAME = "${project.mod_id}"
    private Stack<File> FILE_STACK = null

    def moveFile(File file) {
        println("Working on... "+file.getCanonicalPath())
        if(file.isDirectory()){
            if(file.getName().equals(OLD_NAME)) {
                println("Found file using old mod ID...")
                File dest = new File(file.getAbsolutePath().replace(OLD_NAME,NEW_NAME));
                if(!file.renameTo(dest)){
                    throw new Exception("Unable to move files from "+file.getAbsolutePath()+" to "+dest.getAbsolutePath())
                }
                FILE_STACK.addAll(dest.listFiles())
            } else{
                FILE_STACK.addAll(file.listFiles())
            }
        }else {
            // Try to replace all references of examplemod
            if(file.isFile()){
                String extension = file.getName().substring(file.getName().lastIndexOf('.')+1)
                switch(extension) {
                    case "mcmeta":
                    case "json":
                    case "toml":
                    case "java":
                        String text = file.text
                        file.text = text.replace(OLD_NAME, NEW_NAME)
                        break
                }
            }
        }
    }

    @TaskAction
    def greet() {
        FILE_STACK = new Stack<>()
        FILE_STACK.addAll(new File("${project.projectDir}/src/main").listFiles())
        File file
        while(!FILE_STACK.isEmpty()) {
            file = FILE_STACK.pop()
            moveFile(file)
        }
    }
}

task updateModID(type: ChangeModID) {
    group = 'forgegradle runs'
    description = 'A gradle task to change all references of examplemod, and replace them with the new modID.'
}

class VerifyTextureTask extends DefaultTask {

    static boolean success = false

    def String getAllRegistryNames(path)
    {
        File f = new File(path)
        BufferedReader reader = new BufferedReader(new FileReader(f)) // Right, because nothing can be easy in java >:/
        String results = "";
        String line = reader.readLine()
        // Get every line with a registry name
        while(line != null)
        {
            if((line.contains("setRegistryName") || line.contains("buildBasicItem") || line.contains("createBasicBlock")) && !line.contains("//"))
            {
                String trimmed = line.substring(line.indexOf("\"") + 1, line.lastIndexOf("\""))
                results += trimmed + "-"
            }
            line = reader.readLine()
        }
        reader.close()
        return results;
    }

    def String[] getDirectoryContents(path)
    {
        File dir = new File(path)
        String storage = ""
        for(final File entry : dir.listFiles())
        {
            if(entry.getName().contains(".png")) // Texture
            {
                storage += entry.getName().replace(".png", "") + "-"
            }
            else if(entry.getName().contains(".java") && !entry.getName().contains("Utils")) // Java class that's not ItemUtils
            {
                // Find the registry name(s) of the item(s)
                // Certain classes like armors and -Mod classes may have more than one item inside
                storage += getAllRegistryNames(entry.absolutePath)
            }
        }
        // Remove last hypen
        storage = storage.substring(0, storage.length() - 1)
        // Split into string array
        String[] entries = storage.split("-")
        return entries
    }

    @TaskAction
    def verifyAllTextures() // Compare item and block classes to their texture directories, throws error if a match for a class isn't found.
    {
        success = false
        // Fancy output colors
        final String NO_COLOR= "\u001B[0m"
        final String WHITE_BG = "\u001B[41m"
        final String BLUE = "\u001B[34m"

        // Get all items and item textures
        String[] itemList = getDirectoryContents("$project.projectDir\\src\\main\\java\\com\\idtech\\item\\")
        String[] itemTextures = getDirectoryContents("$project.projectDir\\src\\main\\resources\\assets\\examplemod\\textures\\item\\")

        // Make sure item model has a matching texture
        for(String item : itemList)
        {
            boolean foundMatch = false
            for(String tex : itemTextures)
            {
                if(item.equals(tex))
                {
                    foundMatch = true
                    // Print status
                    project.logger.lifecycle(BLUE + item + " ---> " + tex + ".png" + NO_COLOR)
                }
            }

            // Make sure a match was found
            assert foundMatch : WHITE_BG + item + ".png" + NO_COLOR + " could not be found!"
        }

        //Get all blocks and block textures
        String[] blockList = getDirectoryContents("$project.projectDir\\src\\main\\java\\com\\idtech\\block\\")
        String[] blockTextures = getDirectoryContents("$project.projectDir\\src\\main\\resources\\assets\\examplemod\\textures\\block\\")

        // Make sure item model has a matching texture
        for(String block : blockList)
        {
            boolean foundMatch = false
            for(String tex : blockTextures)
            {
                // TODO: Better multi-textured block implementation
                // TODO: What to do with commented entries?
                // Currently only checks for the up texture
                if(block.equals(tex) || (block + "_up").equals(tex))
                {
                    foundMatch = true
                    // Print found status
                    project.logger.lifecycle(BLUE + block + " ---> " + tex + ".png" + NO_COLOR)
                }
            }

            // Make sure a match was found
            assert foundMatch : WHITE_BG + block + ".png" + NO_COLOR + " could not be found!"
        }

        // If you made it here, everything listed has a texture. Congrats :)
        success = true
    }

}

task verifyTextures(type: VerifyTextureTask) {
    group = 'forgegradle runs'
    description = 'A gradle task that verifies every block and item has a cooresponding texture.'



    doFirst {
        project.logger.warn( "\u001B[31m" + "WARNING: Do not change any item or block files until this task finishes." + "\u001B[0m" + "\n")
        Thread.sleep(5000) // Make sure people read this warning, we don't want any file corruption. So it's worth the extra 5 seconds
    }

    doLast {
        if(VerifyTextureTask.success)
        {
            project.logger.lifecycle('\n' + "\u001B[32m" + "Yay! No missing textures detected!" + "\u001B[0m")
        }
    }

}




